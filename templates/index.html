<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Radio Audio Logger</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #1a1a1a;
      color: #ffffff;
      line-height: 1.6;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      color: #ecf0f1;
    }

    .header .subtitle {
      font-size: 1.2em;
      color: #bdc3c7;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      align-items: center;
    }

    .search-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-left: auto;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
      color: white;
    }

    .btn-danger {
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      color: white;
    }

    .btn-info {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
      color: white;
    }

    .btn-secondary {
      background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);
      color: white;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    .input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .input-group label {
      color: #bdc3c7;
      font-size: 14px;
      white-space: nowrap;
    }

    .input-group input {
      padding: 8px 12px;
      border: 1px solid #34495e;
      border-radius: 4px;
      background: #2c3e50;
      color: #ecf0f1;
      font-size: 14px;
    }

    .status-bar {
      background: #2c3e50;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .status-recording {
      background: #e74c3c;
    }

    .status-idle {
      background: #95a5a6;
    }

    .status-warning {
      background: #f39c12;
    }

    .status-degraded {
      background: #e67e22;
    }

    .status-failed {
      background: #c0392b;
    }

    .status-healthy {
      background: #27ae60;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }

    .main-content {
      display: block;
      margin-bottom: 30px;
    }

    .section {
      background: #34495e;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      margin-bottom: 20px;
    }

    .section h3 {
      margin-bottom: 20px;
      color: #ecf0f1;
      border-bottom: 2px solid #3498db;
      padding-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .channels-table {
      width: 100%;
      border-collapse: collapse;
      background: #2c3e50;
      border-radius: 8px;
      overflow: hidden;
    }

    .channels-table th,
    .channels-table td {
      padding: 8px 12px;
      text-align: left;
      border-bottom: 1px solid #34495e;
    }

    .channels-table th {
      background: #34495e;
      font-weight: 600;
      color: #ecf0f1;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* sortable header indicators */
    .channels-table th[data-sort="asc"]::after  { content: " â–²"; }
    .channels-table th[data-sort="desc"]::after { content: " â–¼"; }

    .channels-table td {
      color: #bdc3c7;
      font-size: 0.85em;
    }

    .channels-table tr:hover { background: #3a4f63; }

    .channel-name {
      font-weight: 600;
      color: #ecf0f1;
      cursor: pointer;
      text-decoration: underline;
    }
    .channel-name:hover { color: #3498db; }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 5px;
    }
    .status-recording { background: #e74c3c; animation: pulse 1.5s infinite; }
    .status-idle { background: #95a5a6; }

    .btn-table {
      padding: 4px 8px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .recent-recordings { font-size: 0.75em; max-width: 200px; }

    .recording-item {
      display: flex; justify-content: space-between; align-items: center;
      padding: 2px 0; border-bottom: 1px solid #444;
    }
    .recording-item:last-child { border-bottom: none; }

    .recording-time { color: #95a5a6; }

    .play-btn {
      background: #27ae60; color: white; border: none; border-radius: 2px;
      padding: 2px 6px; cursor: pointer; font-size: 10px;
    }
    .play-btn:hover { background: #2ecc71; }

    .recording-list { max-height: 500px; overflow-y: auto; }

    .recording-item {
      background: #2c3e50; margin: 4px 0; padding: 8px 12px; border-radius: 6px;
      display: flex; justify-content: space-between; align-items: center;
      transition: background 0.3s ease; font-size: 0.9em;
    }
    .recording-item:hover { background: #34495e; }

    .recording-info { flex: 1; }
    .recording-name { font-weight: 600; color: #ecf0f1; margin-bottom: 4px; }
    .recording-meta { font-size: 0.9em; color: #bdc3c7; }
    .recording-actions { display: flex; gap: 8px; align-items: center; }

    .btn-small {
      padding: 6px 12px; font-size: 12px; border-radius: 4px; border: none;
      cursor: pointer; transition: all 0.3s ease;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px; margin-bottom: 20px;
    }

    .stat-card { background: #2c3e50; padding: 15px; border-radius: 8px; text-align: center; border-top: 3px solid #3498db; }
    .stat-number { font-size: 2em; font-weight: bold; color: #3498db; }
    .stat-label { color: #bdc3c7; font-size: 0.9em; }

    .loading { text-align: center; padding: 20px; color: #bdc3c7; }
    .error { background: #e74c3c; color: white; padding: 10px; border-radius: 6px; margin: 10px 0; }
    .success { background: #27ae60; color: white; padding: 10px; border-radius: 6px; margin: 10px 0; }

    .modal {
      display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
    }
    .modal-content {
      background: #34495e; margin: 2% auto; padding: 15px; border-radius: 10px;
      width: 95%; max-width: 1000px; max-height: 90vh; overflow-y: auto;
    }
    .modal-header {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;
      border-bottom: 2px solid #3498db; padding-bottom: 8px;
    }
    .modal-controls { display: flex; align-items: center; gap: 10px; }

    .refresh-btn {
      background: #3498db; color: white; border: none; padding: 5px 10px; border-radius: 4px;
      cursor: pointer; font-size: 14px; transition: background-color 0.3s ease;
    }
    .refresh-btn:hover { background: #2980b9; }
    .refresh-btn:active { background: #21618c; }

    .close { color: #bdc3c7; font-size: 28px; font-weight: bold; cursor: pointer; transition: color 0.3s ease; }
    .close:hover { color: #ecf0f1; }

    .audio-player { width: 100%; margin: 10px 0; }

    .pagination { display: flex; justify-content: center; gap: 10px; margin-top: 20px; }
    .page-btn {
      padding: 8px 12px; background: #2c3e50; border: 1px solid #34495e; color: #ecf0f1;
      cursor: pointer; border-radius: 4px; transition: all 0.3s ease;
    }
    .page-btn:hover:not(.disabled) { background: #34495e; }
    .page-btn.active { background: #3498db; border-color: #3498db; }
    .page-btn.disabled { opacity: 0.5; cursor: not-allowed; }

    .timezone-info { font-size: 0.8em; color: #95a5a6; margin-top: 5px; }

    /* Modal-specific compact styles */
    .modal .recording-item { margin: 2px 0; padding: 6px 10px; font-size: 0.85em; }
    .modal .recording-info { flex: 1; min-width: 0; }
    .modal .recording-name { font-weight: 500; color: #ecf0f1; margin-bottom: 2px; font-size: 0.9em; }
    .modal .recording-meta { font-size: 0.8em; color: #bdc3c7; line-height: 1.2; }
    .modal .recording-actions { display: flex; gap: 5px; align-items: center; flex-shrink: 0; }
    .modal .btn-small { padding: 4px 8px; font-size: 11px; border-radius: 3px; border: none; cursor: pointer; transition: all 0.2s ease; }

    /* Checkbox styles for batch selection */
    .recording-checkbox { margin-right: 10px; transform: scale(1.2); }

    .batch-controls {
      background: #f5f5f5; padding: 15px; margin-bottom: 15px; border-radius: 5px; border: 1px solid #ddd;
    }
    .batch-controls h3 { margin: 0 0 10px 0; font-size: 1em; color: #333; }

    .batch-actions { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .selected-count { background: #007bff; color: white; padding: 4px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; }
    .btn-batch { background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s; }
    .btn-batch:hover { background: #218838; }
    .btn-batch:disabled { background: #6c757d; cursor: not-allowed; }
    .btn-select-all { background: #17a2b8; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8em; }
    .btn-select-all:hover { background: #138496; }

    /* Date filter styles for modal */
    .date-filters {
      display: flex; gap: 10px; margin-bottom: 15px; padding: 10px; background: #2c3e50;
      border-radius: 6px; align-items: center; flex-wrap: wrap;
    }
    .date-input-group { display: flex; align-items: center; gap: 5px; }
    .date-input-group label { font-size: 0.9em; color: #bdc3c7; white-space: nowrap; }
    .date-input-group input {
      padding: 4px 6px; border: 1px solid #34495e; border-radius: 3px; background: #34495e; color: #ecf0f1; font-size: 0.85em;
    }
    .filter-btn { padding: 6px 12px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em; transition: background 0.3s ease; }
    .filter-btn:hover { background: #2980b9; }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>ðŸš” Radio Audio Logger ðŸš’</h1>
      <p class="subtitle">
        Experimental recording of emergency services
        communications
      <div class="timezone-info">
        All times are shown in your local timezone (<span id="tzDisplay"></span>).
      </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
      <div class="status-item">
        <span class="status-indicator" id="systemStatus"></span>
        <span id="systemStatusText">Checking status...</span>
      </div>
      <div class="status-item">
        <strong id="activeChannels">0</strong>
        <span>Active Channels</span>
      </div>
      <div class="status-item">
        <strong id="totalRecordings">0</strong>
        <span>Total Recordings Today</span>
      </div>
    </div>

    <!-- Channels Section -->
    <div class="section">
      <h2>ðŸ“» Channels</h2>
      <div id="channelsContainer" class="channels-container">
        <p class="loading">Loading channels...</p>
      </div>
    </div>

    <!-- Channel Recordings Modal -->
    <div id="channelModal" class="modal" style="display: none">
      <div class="modal-content">
        <div class="modal-header">
          <h2 id="modalChannelName">Channel Recordings</h2>
          <div class="modal-controls">
            <button onclick="refreshChannelRecordings()" class="refresh-btn" title="Refresh recordings list">
              â†» Refresh
            </button>
            <span class="close" onclick="closeChannelModal()">&times;</span>
          </div>
        </div>

        <!-- Date Filter Controls -->
        <div class="date-filters">
          <div class="date-input-group">
            <label for="startDate">Start Date:</label>
            <input type="date" id="startDate" />
            <label for="startTime">Start Time:</label>
            <input type="time" id="startTime" />
          </div>
          <div class="date-input-group">
            <label for="endDate">End Date:</label>
            <input type="date" id="endDate" />
            <label for="endTime">End Time:</label>
            <input type="time" id="endTime" />
          </div>
          <button onclick="filterRecordings()" class="filter-btn">
            Apply Filter
          </button> (Times are approximate.)
        </div>

        <!-- Batch Selection Controls -->
        <div id="batchControls" class="batch-controls" style="display: none;">
          <h3>Batch Actions</h3>
          <div class="batch-actions">
            <span id="selectedCount" class="selected-count">0 selected</span>
            <button onclick="selectAllRecordings()" class="btn-select-all">Select All</button>
            <button onclick="clearSelection()" class="btn-select-all">Clear Selection</button>
            <button id="playBatchBtn" onclick="playSelectedRecordings()" class="btn-batch" disabled>
              Play Selected in Sequence
            </button>
            <button id="downloadBatchBtn" onclick="downloadSelectedRecordings()" class="btn-batch" disabled>
              Download Selected
            </button>
          </div>
        </div>

        <div id="modalRecordingsContainer" class="recording-list">
          <!-- Recordings will be loaded here -->
        </div>
      </div>
    </div>
  </div>
  </div>
  </div>
  </div>

  <script>
    // Immediately try to call the API to test
    fetch("/api/channels").then(r => r.json()).catch(e => console.error("API Error:", e));

    let refreshInterval;
    let currentChannelStats = {};
    let currentChannelId = null;
    let currentChannelName = null;

    const LA_TIMEZONE = "America/Los_Angeles";

    // ---- sorting helper (new) ----
    function enableTableSorting(table) {
      const headerCells = table.tHead?.rows[0]?.cells || [];
      [...headerCells].forEach((th, colIdx) => {
        const type = th.dataset.type; // "text" | "number"
        if (!type) return;
        th.style.cursor = "pointer";
        th.addEventListener("click", () => {
          const current = th.dataset.sort || "none";
          const dir = current === "asc" ? "desc" : "asc";
          [...headerCells].forEach(h => h.removeAttribute("data-sort"));
          th.setAttribute("data-sort", dir);

          const rows = [...table.tBodies[0].rows];
          const collator = new Intl.Collator(undefined, { sensitivity: "base" });

          rows.sort((a, b) => {
            let av = a.cells[colIdx].innerText.trim();
            let bv = b.cells[colIdx].innerText.trim();
            if (type === "number") {
              av = parseFloat(av) || 0;
              bv = parseFloat(bv) || 0;
              return av - bv;
            }
            return collator.compare(av, bv);
          });

          if (dir === "desc") rows.reverse();
          const frag = document.createDocumentFragment();
          rows.forEach(r => frag.appendChild(r));
          table.tBodies[0].appendChild(frag);
        });
      });
    }
    // -------------------------------

    async function loadChannels() {
      try {
        const [channelsResponse, statusResponse, minutesResponse] = await Promise.all([
          fetch("/api/channels"),
          fetch("/api/status"),
          fetch("/api/channel-minutes"),
        ]);

        const channels = await channelsResponse.json();
        const status = await statusResponse.json();
        const channelMinutes = await minutesResponse.json();
        console.log("Channels loaded:", Object.keys(channels).length);

        const container = document.getElementById("channelsContainer");
        container.innerHTML = "";

        if (Object.keys(channels).length === 0) {
          container.innerHTML = "<p>No channels configured</p>";
          return;
        }

        const table = document.createElement("table");
        table.className = "channels-table";

        // header now has data-type attributes (new)
        table.innerHTML = `
          <thead>
            <tr>
              <th data-type="text">Group</th>
              <th data-type="text">Channel</th>
              <th data-type="number">Minutes for 7 days</th>
            </tr>
          </thead>
          <tbody id="channelsTableBody"></tbody>
        `;

        const tbody = table.querySelector("#channelsTableBody");

        Object.entries(channels).forEach(([channelId, channel]) => {
          const minutes = channelMinutes[channelId] || 0;
          const formattedMinutes = minutes < 1 ? minutes.toFixed(1).padStart(3, '0') : minutes.toFixed(1);
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${channel.group || "Unknown"}</td>
            <td>
              <div class="channel-name" data-channel-id="${channelId}" data-channel-name="${channel.name.replace(/"/g, '&quot;')}">
                ${channel.name}
              </div>
            </td>
            <td>${formattedMinutes}</td>
          `;
          tbody.appendChild(row);
        });

        container.appendChild(table);

        // enable sorting (new)
        enableTableSorting(table);

        // Add click event listeners to channel names
        const channelElements = document.querySelectorAll('.channel-name');
        channelElements.forEach((element) => {
          element.addEventListener('click', function () {
            const channelId = this.getAttribute('data-channel-id');
            const channelName = this.getAttribute('data-channel-name');
            try {
              openChannelModal(channelId, channelName);
            } catch (error) {
              console.error('Error in openChannelModal:', error);
              alert('Error opening modal: ' + error.message);
            }
          });
          element.style.cursor = 'pointer';
        });

      } catch (error) {
        console.error("Error loading channels:", error);
        document.getElementById("channelsContainer").innerHTML = "<p>Error loading channels</p>";
      }
    }

    document.addEventListener("DOMContentLoaded", function () {
      Promise.all([loadChannels(), updateStatus()])
        .then(() => {
          setInterval(() => { updateStatus(); }, 5000);
        })
        .catch(error => { console.error("Error during initialization:", error); });
    });

    async function updateStatus() {
      try {
        const response = await fetch("/api/status");
        const status = await response.json();

        const recordingChannels = Object.values(status).filter((s) => s.recording).length;

        const systemStatus = document.getElementById("systemStatus");
        const systemStatusText = document.getElementById("systemStatusText");

        if (recordingChannels > 0) {
          systemStatus.className = "status-indicator status-recording";
          systemStatusText.textContent = "Recording Active";
        } else {
          systemStatus.className = "status-indicator status-idle";
          systemStatusText.textContent = "System Idle";
        }

        const activeChannelsElement = document.getElementById("activeChannels");
        if (activeChannelsElement) {
          activeChannelsElement.textContent = recordingChannels;
        } else {
          console.error("activeChannels element not found!");
        }

        updateTodaysRecordingCount();
        updateChannelMinutes();
      } catch (error) {
        console.error("Error updating status:", error);
        const systemStatus = document.getElementById("systemStatus");
        const systemStatusText = document.getElementById("systemStatusText");
        systemStatus.className = "status-indicator status-idle";
        systemStatusText.textContent = "Connection Error";

        const activeChannelsElement = document.getElementById("activeChannels");
        if (activeChannelsElement) {
          activeChannelsElement.textContent = "N/A";
        }
        document.getElementById("totalRecordings").textContent = "Error";
      }
    }

    async function updateTodaysRecordingCount() {
      try {
        const response = await fetch("/api/stats");
        const stats = await response.json();
        if (stats.total && typeof stats.total.today === 'number') {
          document.getElementById("totalRecordings").textContent = stats.total.today;
        } else {
          document.getElementById("totalRecordings").textContent = "0";
        }
      } catch (error) {
        console.error("Error fetching stats:", error);
        document.getElementById("totalRecordings").textContent = "N/A";
      }
    }

    async function updateChannelMinutes() {
      try {
        const response = await fetch("/api/channel-minutes");
        const channelMinutes = await response.json();

        const table = document.querySelector('.channels-table');
        if (table) {
          const rows = table.querySelectorAll('tbody tr');
          rows.forEach(row => {
            const channelNameDiv = row.querySelector('.channel-name');
            if (channelNameDiv) {
              const channelId = channelNameDiv.getAttribute('data-channel-id');
              const minutesCell = row.cells[2];
              if (minutesCell && channelId) {
                const minutes = channelMinutes[channelId] || 0;
                const formattedMinutes = minutes < 1 ? minutes.toFixed(1).padStart(3, '0') : minutes.toFixed(1);
                minutesCell.textContent = formattedMinutes;
              }
            }
          });
        }
      } catch (error) {
        console.error("Error updating channel minutes:", error);
      }
    }

    function formatDateForInput(date) {
      return date.toISOString().split("T")[0];
    }

    
    // Parse our YYYYMMDD_HHMMSS[_mmm] style timestamps as UTC, return Date in local time zone
    function parseTimestampToUTC(ts) {
      if (typeof ts !== 'string') return new Date(ts);
      const m = ts.match(/^(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})/);
      if (!m) return new Date(ts);
      const [_, y, mo, d, h, mi, s] = m;
      return new Date(Date.UTC(+y, +mo - 1, +d, +h, +mi, +s));
    }
function formatDateTimeForLA(timestamp) {
      try {
        let date;
        if (typeof timestamp === 'string') {
          if (/^\d{8}_\d{6}/.test(timestamp)) {
            date = parseTimestampToUTC(timestamp);
          } else {
            date = new Date(timestamp);
          }
        } else {
          date = new Date(timestamp);
        }
        if (isNaN(date.getTime())) {
          console.warn('Invalid date:', timestamp);
          return timestamp;
        }
        const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
        return date.toLocaleString('en-US', options);
      } catch (e) {
        console.error('Error formatting date:', e, 'timestamp:', timestamp);
        return timestamp;
      }
    }

    // Show viewer's local tz name in header
    (function setTzName() {
      try {
        const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'Local';
        document.getElementById('tzDisplay').textContent = tz;
      } catch (_) { document.getElementById('tzDisplay').textContent = 'Local'; }
    })();

    function showMessage(message, type = "info") {
      if (type === "error") { alert(`Error: ${message}`); }
    }

    async function refreshData() {
      try {
        await Promise.all([loadChannels(), loadStats(), updateStatus()]);
        document.getElementById("lastUpdate").textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
      } catch (error) {
        console.error("Error refreshing data:", error);
        showMessage("Error refreshing data: " + error.message, "error");
      }
    }

    async function getLatestRecording(channelId) {
      try {
        const response = await fetch(`/api/recordings?channel=${channelId}&limit=1`);
        const recordings = await response.json();
        if (recordings.length === 0) { return 'None'; }
        return formatDateTimeForLA(recordings[0].timestamp);
      } catch (error) {
        console.error("Error loading latest recording:", error);
        return 'Error';
      }
    }

    async function loadChannelStats() {
      try {
        const response = await fetch("/api/stats");
        const stats = await response.json();
        currentChannelStats = stats;
      } catch (error) {
        console.error("Error loading channel stats:", error);
      }
    }

    async function loadStats() {
      try {
        const response = await fetch("/api/stats");
        const stats = await response.json();

        const container = document.getElementById("statsContainer");
        container.innerHTML = "";

        const grid = document.createElement("div");
        grid.className = "stats-grid";

        if (stats.total) {
          grid.innerHTML = `
            <div class="stat-card">
              <div class="stat-number">${stats.total.recordings}</div>
              <div class="stat-label">Total Recordings</div>
            </div>
            <div class="stat-card">
              <div class="stat-number">${stats.total.channels}</div>
              <div class="stat-label">Channels</div>
            </div>
            <div class="stat-card">
              <div class="stat-number">${formatFileSize(stats.total.total_size)}</div>
              <div class="stat-label">Total Size</div>
            </div>
          `;
        }

        container.appendChild(grid);
      } catch (error) {
        document.getElementById("statsContainer").innerHTML = '<p class="error">Error loading statistics</p>';
        throw error;
      }
    }

    async function openChannelModal(channelId, channelName) {
      currentChannelId = channelId;
      currentChannelName = channelName;

      document.getElementById("modalChannelName").textContent = `${channelName} Recordings`;
      document.getElementById("channelModal").style.display = "block";

      const today = new Date();
      const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
      document.getElementById("endDate").value = formatDateForInput(today);
      document.getElementById("startDate").value = formatDateForInput(weekAgo);

      document.getElementById("startTime").value = "00:00";
      document.getElementById("endTime").value = "23:59";

      const container = document.getElementById("modalRecordingsContainer");
      container.innerHTML = '<div class="loading">Loading recordings...</div>';

      try {
        const startDate = document.getElementById("startDate").value;
        const endDate = document.getElementById("endDate").value;
        const startTime = document.getElementById("startTime").value;
        const endTime = document.getElementById("endTime").value;

        let url = `/api/recordings/channel/${channelId}?limit=200`;
        if (startDate) {
          const startDateTime = startTime ? `${startDate}T${startTime}` : startDate;
          url += `&start_date=${startDateTime}`;
        }
        if (endDate) {
          const endDateTime = endTime ? `${endDate}T${endTime}` : endDate;
          url += `&end_date=${endDateTime}`;
        }

        const response = await fetch(url);
        if (!response.ok) { throw new Error(`HTTP ${response.status}: ${response.statusText}`); }
        const data = await response.json();

        container.innerHTML = "";
        const recordings = Array.isArray(data) ? data : data.recordings || [];

        if (recordings.length > 0) {
          const list = document.createElement("div");
          list.className = "recording-list";

          recordings.forEach((recording) => {
            const item = document.createElement("div");
            item.className = "recording-item";

            let formattedTime = recording.timestamp || 'Unknown time';
            try { formattedTime = formatDateTimeForLA(recording.timestamp); } catch (_) {}

            const duration = recording.duration_ms
              ? `${(recording.duration_ms / 1000).toFixed(1)}s`
              : recording.duration ? `${recording.duration}s` : "Unknown";

            item.innerHTML = `
              <input type="checkbox" class="recording-checkbox" 
                     data-filename="${recording.filename}"
                     data-timestamp="${recording.timestamp}" 
                     onchange="updateBatchControls()">
              <div class="recording-info">
                <div class="recording-name">${recording.filename}</div>
                <div class="recording-meta">${formattedTime} â€¢ ${duration} â€¢ ${formatFileSize(recording.size || 0)}</div>
              </div>
              <div class="recording-actions">
                <button class="btn-small btn-primary" onclick="playRecording('${recording.filename}', '${channelName}')">Play</button>
                <button class="btn-small btn-info" onclick="downloadRecording('${recording.filename}')">Download</button>
              </div>
            `;
            list.appendChild(item);
          });

          container.appendChild(list);

          if (!Array.isArray(data) && data.has_more) {
            const info = document.createElement("div");
            info.className = "pagination";
            info.innerHTML = `<p>Showing ${recordings.length} of ${data.total} recordings</p>`;
            container.appendChild(info);
          }

          updateBatchControls();
        } else {
          container.innerHTML = `
            <p>No recordings found for this channel in the selected date range</p>
            <p style="font-size: 0.8em; color: #888;">
              API URL: ${url}<br>
              Total records: ${data.total || 'N/A'}<br>
              Response type: ${Array.isArray(data) ? 'Array' : 'Object'}<br>
              Recordings array length: ${recordings.length}
            </p>
          `;
          document.getElementById('batchControls').style.display = 'none';
        }
      } catch (error) {
        container.innerHTML = '<p class="error">Error loading channel recordings</p>';
        console.error("Error loading channel recordings:", error);
        document.getElementById('batchControls').style.display = 'none';
      }
    }

    function closeChannelModal() {
      document.getElementById("channelModal").style.display = "none";
    }

    function refreshChannelRecordings() {
      if (!(currentChannelId && currentChannelName)) return;

      const container = document.getElementById("modalRecordingsContainer");
      container.innerHTML = '<div class="loading">Refreshing recordings...</div>';

      (async () => {
        try {
          const startDate = document.getElementById("startDate").value;
          const endDate = document.getElementById("endDate").value;
          const startTime = document.getElementById("startTime").value;
          const endTime = document.getElementById("endTime").value;

          let url = `/api/recordings/channel/${currentChannelId}?limit=200`;
          if (startDate) {
            const startDateTime = startTime ? `${startDate}T${startTime}` : startDate;
            url += `&start_date=${startDateTime}`;
          }
          if (endDate) {
            const endDateTime = endTime ? `${endDate}T${endTime}` : endDate;
            url += `&end_date=${endDateTime}`;
          }

          const response = await fetch(url);
          if (!response.ok) { throw new Error(`HTTP ${response.status}: ${response.statusText}`); }
          const data = await response.json();

          container.innerHTML = "";
          const recordings = Array.isArray(data) ? data : data.recordings || [];

          if (recordings.length > 0) {
            const list = document.createElement("div");
            list.className = "recording-list";

            recordings.forEach((recording) => {
              const item = document.createElement("div");
              item.className = "recording-item";

              let formattedTime = recording.timestamp || 'Unknown time';
              try { formattedTime = formatDateTimeForLA(recording.timestamp); } catch (_) {}

              const duration = recording.duration_ms
                ? `${(recording.duration_ms / 1000).toFixed(1)}s`
                : recording.duration ? `${recording.duration}s` : "Unknown";

              item.innerHTML = `
                <input type="checkbox" class="recording-checkbox" 
                       data-filename="${recording.filename}"
                       data-timestamp="${recording.timestamp}" 
                       onchange="updateBatchControls()">
                <div class="recording-info">
                  <div class="recording-name">${recording.filename}</div>
                  <div class="recording-meta">${formattedTime} â€¢ ${duration} â€¢ ${formatFileSize(recording.size || 0)}</div>
                </div>
                <div class="recording-actions">
                  <button class="btn-small btn-primary" onclick="playRecording('${recording.filename}', '${currentChannelName}')">Play</button>
                  <button class="btn-small btn-info" onclick="downloadRecording('${recording.filename}')">Download</button>
                </div>
              `;
              list.appendChild(item);
            });

            container.appendChild(list);

            if (!Array.isArray(data) && data.has_more) {
              const info = document.createElement("div");
              info.className = "pagination";
              info.innerHTML = `<p>Showing ${recordings.length} of ${data.total} recordings</p>`;
              container.appendChild(info);
            }

            updateBatchControls();
          } else {
            container.innerHTML = '<div class="no-recordings">No recordings found for the selected date range.</div>';
          }
        } catch (error) {
          console.error('Error refreshing recordings:', error);
          container.innerHTML = `<div class="error">Error refreshing recordings: ${error.message}</div>`;
        }
      })();
    }

    function filterRecordings() {
      if (!(currentChannelId && currentChannelName)) return;

      const container = document.getElementById("modalRecordingsContainer");
      container.innerHTML = '<div class="loading">Filtering recordings...</div>';

      const startDate = document.getElementById("startDate").value;
      const endDate = document.getElementById("endDate").value;
      const startTime = document.getElementById("startTime").value;
      const endTime = document.getElementById("endTime").value;

      let url = `/api/recordings/channel/${currentChannelId}?limit=200`;
      if (startDate) {
        const startDateTime = startTime ? `${startDate}T${startTime}` : startDate;
        url += `&start_date=${startDateTime}`;
      }
      if (endDate) {
        const endDateTime = endTime ? `${endDate}T${endTime}` : endDate;
        url += `&end_date=${endDateTime}`;
      }

      fetch(url)
        .then(response => {
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          return response.json();
        })
        .then(data => {
          const recordings = Array.isArray(data) ? data : data.recordings || [];
          container.innerHTML = "";

          if (recordings.length > 0) {
            const list = document.createElement("div");
            list.className = "recording-list";

            recordings.forEach((recording) => {
              const item = document.createElement("div");
              item.className = "recording-item";

              let formattedTime = recording.timestamp || 'Unknown time';
              try { formattedTime = formatDateTimeForLA(recording.timestamp); } catch (_) {}

              const duration = recording.duration_ms
                ? `${(recording.duration_ms / 1000).toFixed(1)}s`
                : recording.duration ? `${recording.duration}s` : "Unknown";

              item.innerHTML = `
                <input type="checkbox" class="recording-checkbox" 
                       data-filename="${recording.filename}"
                       data-timestamp="${recording.timestamp}" 
                       onchange="updateBatchControls()">
                <div class="recording-info">
                  <div class="recording-name">${recording.filename}</div>
                  <div class="recording-meta">${formattedTime} â€¢ ${duration} â€¢ ${formatFileSize(recording.size || 0)}</div>
                </div>
                <div class="recording-actions">
                  <button class="btn-small btn-primary" onclick="playRecording('${recording.filename}', '${currentChannelName}')">Play</button>
                  <button class="btn-small btn-info" onclick="downloadRecording('${recording.filename}')">Download</button>
                </div>
              `;
              list.appendChild(item);
            });

            container.appendChild(list);

            if (!Array.isArray(data) && data.has_more) {
              const info = document.createElement("div");
              info.className = "pagination";
              info.innerHTML = `<p>Showing ${recordings.length} of ${data.total} recordings</p>`;
              container.appendChild(info);
            }

            updateBatchControls();
          } else {
            container.innerHTML = '<div class="no-recordings">No recordings found for the selected date range.</div>';
          }
        })
        .catch(error => {
          console.error('Error filtering recordings:', error);
          container.innerHTML = `<div class="error">Error filtering recordings: ${error.message}</div>`;
        });
    }

    // Close modal when clicking outside
    window.onclick = function (event) {
      const modal = document.getElementById("channelModal");
      if (event.target == modal) {
        modal.style.display = "none";
      }
    };

    function getAudioSources(filename) {
      const fileExtension = filename.toLowerCase().split('.').pop();
      const baseSrc = `/api/recording/${filename}`;
      if (fileExtension === 'flac') {
        return `<source src="${baseSrc}" type="audio/flac">
                <source src="${baseSrc}" type="audio/x-flac">`;
      } else if (fileExtension === 'mp3') {
        return `<source src="${baseSrc}" type="audio/mpeg">
                <source src="${baseSrc}" type="audio/mp3">`;
      } else {
        return `<source src="${baseSrc}" type="audio/mpeg">
                <source src="${baseSrc}" type="audio/mp3">`;
      }
    }

    function playRecording(filename, channelName) {
      const audioModal = document.createElement("div");
      audioModal.className = "modal";
      audioModal.style.display = "block";

      audioModal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
          <div class="modal-header">
            <h3>Playing: ${channelName}</h3>
            <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
          </div>
          <div style="padding: 20px;">
            <p style="margin-bottom: 15px; color: #bdc3c7;">${filename}</p>
            <div id="audio-status" style="margin-bottom: 10px; color: #3498db; font-size: 14px;">Loading audio...</div>
            <audio controls preload="metadata" class="audio-player" id="audio-player-${Date.now()}">
              ${getAudioSources(filename)}
              Your browser does not support the audio element.
            </audio>
          </div>
        </div>
      `;

      document.body.appendChild(audioModal);

      const audioElement = audioModal.querySelector('audio');
      const statusElement = audioModal.querySelector('#audio-status');

      audioElement.addEventListener('loadedmetadata', function () {
        const duration = audioElement.duration;
        if (duration && !isNaN(duration)) {
          statusElement.textContent = `Duration: ${duration.toFixed(1)}s`;
          statusElement.style.color = '#27ae60';
          audioElement.play().catch(() => {
            statusElement.textContent = 'Click play to start (autoplay blocked)';
            statusElement.style.color = '#f39c12';
          });
        } else {
          statusElement.textContent = 'Duration unknown - file may be corrupted';
          statusElement.style.color = '#e74c3c';
        }
      });

      audioElement.addEventListener('error', function (e) {
        statusElement.textContent = 'Error loading audio file';
        statusElement.style.color = '#e74c3c';
        console.error('Audio error:', e);
      });

      audioElement.addEventListener('canplay', function () {
        if (statusElement.textContent === 'Loading audio...') {
          statusElement.textContent = 'Ready to play';
          statusElement.style.color = '#27ae60';
        }
      });

      audioModal.onclick = function (event) {
        if (event.target === audioModal) {
          audioModal.remove();
        }
      };
    }

    async function startRecording(channelIds = null) {
      try {
        const response = await fetch("/api/start", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ channels: channelIds }),
        });

        const result = await response.json();

        if (result.status === "success") {
          showMessage(result.message, "success");
          refreshData();
        } else {
          showMessage(result.message, "error");
        }
      } catch (error) {
        showMessage("Error starting recording: " + error.message, "error");
      }
    }

    async function stopRecording(channelIds = null) {
      try {
        const response = await fetch("/api/stop", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ channels: channelIds }),
        });

        const result = await response.json();

        if (result.status === "success") {
          showMessage(result.message, "success");
          refreshData();
        } else {
          showMessage(result.message, "error");
        }
      } catch (error) {
        showMessage("Error stopping recording: " + error.message, "error");
      }
    }

    function startAllRecording() { startRecording(); }
    function stopAllRecording() { stopRecording(); }

    function downloadRecording(filename) {
      window.open(`/api/recording/${filename}`, "_blank");
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }

    // Batch playback/selection logic unchanged...
    let currentAudioPlayer = null;
    let batchPlaybackQueue = [];
    let currentPlaybackIndex = 0;

    function updateBatchControls() {
      const checkboxes = document.querySelectorAll('.recording-checkbox:checked');
      const count = checkboxes.length;

      const selectedCountElement = document.getElementById('selectedCount');
      const playBatchBtn = document.getElementById('playBatchBtn');
      const downloadBatchBtn = document.getElementById('downloadBatchBtn');
      const batchControls = document.getElementById('batchControls');

      selectedCountElement.textContent = `${count} selected`;
      playBatchBtn.disabled = count === 0;
      downloadBatchBtn.disabled = count === 0;

      const allCheckboxes = document.querySelectorAll('.recording-checkbox');
      batchControls.style.display = allCheckboxes.length > 0 ? 'block' : 'none';
    }

    function selectAllRecordings() {
      const checkboxes = document.querySelectorAll('.recording-checkbox');
      checkboxes.forEach(cb => cb.checked = true);
      updateBatchControls();
    }

    function clearSelection() {
      const checkboxes = document.querySelectorAll('.recording-checkbox');
      checkboxes.forEach(cb => cb.checked = false);
      updateBatchControls();
    }

    function playSelectedRecordings() {
      const selectedCheckboxes = document.querySelectorAll('.recording-checkbox:checked');
      if (selectedCheckboxes.length === 0) { showMessage('Please select recordings to play', 'error'); return; }

      const selectedRecordings = Array.from(selectedCheckboxes).map(cb => {
        const filename = cb.getAttribute('data-filename');
        const timestamp = cb.getAttribute('data-timestamp');
        let parsedDate;
        try {
          if (timestamp && timestamp.match(/^\d{8}_\d{6}/)) {
            const year = timestamp.substring(0, 4);
            const month = timestamp.substring(4, 6);
            const day = timestamp.substring(6, 8);
            const hour = timestamp.substring(9, 11);
            const minute = timestamp.substring(11, 13);
            const second = timestamp.substring(13, 15);
            parsedDate = new Date(year, month - 1, day, hour, minute, second);
          } else {
            parsedDate = new Date(timestamp);
          }
        } catch (e) {
          parsedDate = new Date(0);
        }
        return { filename, timestamp: parsedDate, rawTimestamp: timestamp };
      });

      selectedRecordings.sort((a, b) => a.timestamp - b.timestamp);
      batchPlaybackQueue = selectedRecordings.map(r => r.filename);
      currentPlaybackIndex = 0;
      playBatchRecording();
    }

    function playBatchRecording() {
      if (currentPlaybackIndex >= batchPlaybackQueue.length) { showMessage('Batch playback completed', 'success'); return; }
      const filename = batchPlaybackQueue[currentPlaybackIndex];
      const channelName = currentChannelName || 'Unknown Channel';

      const existingModal = document.querySelector('.batch-audio-modal');
      if (existingModal) existingModal.remove();

      const audioModal = document.createElement("div");
      audioModal.className = "modal batch-audio-modal";
      audioModal.style.display = "block";
      audioModal.innerHTML = `
        <div class="modal-content" style="max-width: 600px;">
          <div class="modal-header">
            <h3>Batch Playback: ${channelName}</h3>
            <span class="close" onclick="stopBatchPlayback()">&times;</span>
          </div>
          <div style="padding: 20px;">
            <p><strong>Playing ${currentPlaybackIndex + 1} of ${batchPlaybackQueue.length}:</strong></p>
            <p style="word-break: break-all; font-size: 0.9em; color: #666;">${filename}</p>
            <audio controls autoplay style="width: 100%; margin: 15px 0;">
              ${getAudioSources(filename)}
              Your browser does not support the audio element.
            </audio>
            <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: space-between;">
              <div>
                <button onclick="previousBatchRecording()" ${currentPlaybackIndex === 0 ? 'disabled' : ''} class="btn-small btn-info">Previous</button>
                <button onclick="nextBatchRecording()" class="btn-small btn-primary">Next</button>
              </div>
              <button onclick="stopBatchPlayback()" class="btn-small btn-secondary">Stop Batch</button>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(audioModal);

      currentAudioPlayer = audioModal.querySelector('audio');
      currentAudioPlayer.addEventListener('ended', () => {
        currentPlaybackIndex++;
        setTimeout(() => { playBatchRecording(); }, 500);
      });
      currentAudioPlayer.addEventListener('error', () => {
        showMessage(`Error playing ${filename}`, 'error');
        currentPlaybackIndex++;
        setTimeout(() => { playBatchRecording(); }, 1000);
      });
    }

    function nextBatchRecording() {
      if (currentPlaybackIndex < batchPlaybackQueue.length - 1) {
        currentPlaybackIndex++;
        playBatchRecording();
      }
    }

    function previousBatchRecording() {
      if (currentPlaybackIndex > 0) {
        currentPlaybackIndex--;
        playBatchRecording();
      }
    }

    function stopBatchPlayback() {
      const modal = document.querySelector('.batch-audio-modal');
      if (modal) modal.remove();
      if (currentAudioPlayer) { currentAudioPlayer.pause(); currentAudioPlayer = null; }
      batchPlaybackQueue = [];
      currentPlaybackIndex = 0;
    }

    function downloadSelectedRecordings() {
      const selectedCheckboxes = document.querySelectorAll('.recording-checkbox:checked');
      if (selectedCheckboxes.length === 0) { showMessage('Please select recordings to download', 'error'); return; }

      if (selectedCheckboxes.length === 1) {
        const filename = selectedCheckboxes[0].getAttribute('data-filename');
        downloadRecording(filename);
        return;
      }

      const selectedRecordings = Array.from(selectedCheckboxes).map(cb => {
        const filename = cb.getAttribute('data-filename');
        const timestamp = cb.getAttribute('data-timestamp');
        let parsedDate;
        try {
          if (timestamp && timestamp.match(/^\d{8}_\d{6}/)) {
            const year = timestamp.substring(0, 4);
            const month = timestamp.substring(4, 6);
            const day = timestamp.substring(6, 8);
            const hour = timestamp.substring(9, 11);
            const minute = timestamp.substring(11, 13);
            const second = timestamp.substring(13, 15);
            parsedDate = new Date(year, month - 1, day, hour, minute, second);
          } else {
            parsedDate = new Date(timestamp);
          }
        } catch (e) {
          parsedDate = new Date(0);
        }
        return { filename, timestamp: parsedDate, rawTimestamp: timestamp };
      });

      selectedRecordings.sort((a, b) => a.timestamp - b.timestamp);
      const sortedFilenames = selectedRecordings.map(r => r.filename);

      const fileListForUser = sortedFilenames.map((f, i) => `${i + 1}. ${f}`).join('\n');
      const confirmed = confirm(
        `You're about to download and concatenate ${selectedRecordings.length} recordings.\n\n` +
        `Files will be combined in chronological order:\n\n${fileListForUser}\n\n` +
        `Continue with download?`
      );
      if (!confirmed) return;

      showMessage(`Preparing concatenated download of ${selectedRecordings.length} recordings...`, 'info');

      const downloadBtn = document.getElementById('downloadBatchBtn');
      const originalText = downloadBtn.textContent;
      downloadBtn.disabled = true;
      downloadBtn.textContent = 'Processing...';

      const requestData = { files: sortedFilenames, channel_name: currentChannelName || 'mixed' };

      fetch('/api/concatenate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestData)
      })
      .then(response => {
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        return response.json();
      })
      .then(data => {
        if (data.success) {
          const a = document.createElement('a');
          a.href = data.download_url;
          a.download = data.filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          showMessage(`Successfully concatenated ${data.files_concatenated} recordings into ${data.filename}. Files included: ${data.file_list.join(', ')}`, 'success');
        } else {
          throw new Error(data.error || 'Unknown error');
        }
      })
      .catch(error => {
        console.error('Error downloading concatenated recordings:', error);
        showMessage('Error creating concatenated download: ' + error.message, 'error');
      })
      .finally(() => {
        downloadBtn.disabled = false;
        downloadBtn.textContent = originalText;
        updateBatchControls();
      });
    }
  </script>

</body>
</html>
