<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Radio Audio Logger</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #1a1a1a;
      color: #ffffff;
      line-height: 1.6;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      color: #ecf0f1;
    }

    .header .subtitle {
      font-size: 1.2em;
      color: #bdc3c7;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      align-items: center;
    }

    .search-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-left: auto;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
      color: white;
    }

    .btn-danger {
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      color: white;
    }

    .btn-info {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
      color: white;
    }

    .btn-secondary {
      background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);
      color: white;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    .input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .input-group label {
      color: #bdc3c7;
      font-size: 14px;
      white-space: nowrap;
    }

    .input-group input {
      padding: 8px 12px;
      border: 1px solid #34495e;
      border-radius: 4px;
      background: #2c3e50;
      color: #ecf0f1;
      font-size: 14px;
    }

    .status-bar {
      background: #2c3e50;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .status-recording {
      background: #e74c3c;
    }

    .status-idle {
      background: #95a5a6;
    }

    .status-warning {
      background: #f39c12;
    }

    .status-degraded {
      background: #e67e22;
    }

    .status-failed {
      background: #c0392b;
    }

    .status-healthy {
      background: #27ae60;
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }

      100% {
        opacity: 1;
      }
    }

    .main-content {
      display: block;
      margin-bottom: 30px;
    }

    .section {
      background: #34495e;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      margin-bottom: 20px;
    }

    .section h3 {
      margin-bottom: 20px;
      color: #ecf0f1;
      border-bottom: 2px solid #3498db;
      padding-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .channels-table {
      width: 100%;
      border-collapse: collapse;
      background: #2c3e50;
      border-radius: 8px;
      overflow: hidden;
    }

    .channels-table th,
    .channels-table td {
      padding: 8px 12px;
      text-align: left;
      border-bottom: 1px solid #34495e;
    }

    .channels-table th {
      background: #34495e;
      font-weight: 600;
      color: #ecf0f1;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .channels-table td {
      color: #bdc3c7;
      font-size: 0.85em;
    }

    .channels-table tr:hover {
      background: #3a4f63;
    }

    .channel-name {
      font-weight: 600;
      color: #ecf0f1;
      cursor: pointer;
      text-decoration: underline;
    }

    .channel-name:hover {
      color: #3498db;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 5px;
    }

    .status-recording {
      background: #e74c3c;
      animation: pulse 1.5s infinite;
    }

    .status-idle {
      background: #95a5a6;
    }

    .btn-table {
      padding: 4px 8px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .recent-recordings {
      font-size: 0.75em;
      max-width: 200px;
    }

    .recording-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 0;
      border-bottom: 1px solid #444;
    }

    .recording-item:last-child {
      border-bottom: none;
    }

    .recording-time {
      color: #95a5a6;
    }

    .play-btn {
      background: #27ae60;
      color: white;
      border: none;
      border-radius: 2px;
      padding: 2px 6px;
      cursor: pointer;
      font-size: 10px;
    }

    .play-btn:hover {
      background: #2ecc71;
    }

    .recording-list {
      max-height: 500px;
      overflow-y: auto;
    }

    .recording-item {
      background: #2c3e50;
      margin: 4px 0;
      padding: 8px 12px;
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.3s ease;
      font-size: 0.9em;
    }

    .recording-item:hover {
      background: #34495e;
    }

    .recording-info {
      flex: 1;
    }

    .recording-name {
      font-weight: 600;
      color: #ecf0f1;
      margin-bottom: 4px;
    }

    .recording-meta {
      font-size: 0.9em;
      color: #bdc3c7;
    }

    .recording-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .btn-small {
      padding: 6px 12px;
      font-size: 12px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: #2c3e50;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      border-top: 3px solid #3498db;
    }

    .stat-number {
      font-size: 2em;
      font-weight: bold;
      color: #3498db;
    }

    .stat-label {
      color: #bdc3c7;
      font-size: 0.9em;
    }

    .loading {
      text-align: center;
      padding: 20px;
      color: #bdc3c7;
    }

    .error {
      background: #e74c3c;
      color: white;
      padding: 10px;
      border-radius: 6px;
      margin: 10px 0;
    }

    .success {
      background: #27ae60;
      color: white;
      padding: 10px;
      border-radius: 6px;
      margin: 10px 0;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
    }

    .modal-content {
      background: #34495e;
      margin: 2% auto;
      padding: 15px;
      border-radius: 10px;
      width: 95%;
      max-width: 1000px;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      border-bottom: 2px solid #3498db;
      padding-bottom: 8px;
    }

    .modal-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .refresh-btn {
      background: #3498db;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s ease;
    }

    .refresh-btn:hover {
      background: #2980b9;
    }

    .refresh-btn:active {
      background: #21618c;
    }

    .close {
      color: #bdc3c7;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.3s ease;
    }

    .close:hover {
      color: #ecf0f1;
    }

    .audio-player {
      width: 100%;
      margin: 10px 0;
    }

    .pagination {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }

    .page-btn {
      padding: 8px 12px;
      background: #2c3e50;
      border: 1px solid #34495e;
      color: #ecf0f1;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.3s ease;
    }

    .page-btn:hover:not(.disabled) {
      background: #34495e;
    }

    .page-btn.active {
      background: #3498db;
      border-color: #3498db;
    }

    .page-btn.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .timezone-info {
      font-size: 0.8em;
      color: #95a5a6;
      margin-top: 5px;
    }

    /* Modal-specific compact styles */
    .modal .recording-item {
      margin: 2px 0;
      padding: 6px 10px;
      font-size: 0.85em;
    }

    .modal .recording-info {
      flex: 1;
      min-width: 0;
    }

    .modal .recording-name {
      font-weight: 500;
      color: #ecf0f1;
      margin-bottom: 2px;
      font-size: 0.9em;
    }

    .modal .recording-meta {
      font-size: 0.8em;
      color: #bdc3c7;
      line-height: 1.2;
    }

    .modal .recording-actions {
      display: flex;
      gap: 5px;
      align-items: center;
      flex-shrink: 0;
    }

    .modal .btn-small {
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 3px;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    /* Checkbox styles for batch selection */
    .recording-checkbox {
      margin-right: 10px;
      transform: scale(1.2);
    }

    .batch-controls {
      background: #f5f5f5;
      padding: 15px;
      margin-bottom: 15px;
      border-radius: 5px;
      border: 1px solid #ddd;
    }

    .batch-controls h3 {
      margin: 0 0 10px 0;
      font-size: 1em;
      color: #333;
    }

    .batch-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .selected-count {
      background: #007bff;
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8em;
      font-weight: bold;
    }

    .btn-batch {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      transition: background-color 0.2s;
    }

    .btn-batch:hover {
      background: #218838;
    }

    .btn-batch:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }

    .btn-select-all {
      background: #17a2b8;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
    }

    .btn-select-all:hover {
      background: #138496;
    }

    /* Date filter styles for modal */
    .date-filters {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      padding: 10px;
      background: #2c3e50;
      border-radius: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    .date-input-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .date-input-group label {
      font-size: 0.9em;
      color: #bdc3c7;
      white-space: nowrap;
    }

    .date-input-group input {
      padding: 4px 6px;
      border: 1px solid #34495e;
      border-radius: 3px;
      background: #34495e;
      color: #ecf0f1;
      font-size: 0.85em;
    }

    .filter-btn {
      padding: 6px 12px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85em;
      transition: background 0.3s ease;
    }

    .filter-btn:hover {
      background: #2980b9;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>🚔 Radio Audio Logger</h1>
      <p class="subtitle">
        Experimental recording of emergency services
        communications
      </p>
      <div class="timezone-info">
        All times are approximate and displayed in Pacific timezone (PST/PDT)
      </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
      <div class="status-item">
        <span class="status-indicator" id="systemStatus"></span>
        <span id="systemStatusText">Checking status...</span>
      </div>
      <div class="status-item">
        <strong id="activeChannels">0</strong>
        <span>Active Channels</span>
      </div>
      <div class="status-item">
        <strong id="totalRecordings">0</strong>
        <span>Total Recordings Today</span>
      </div>
    </div>

    <!-- Channels Section -->
    <div class="section">
      <h2>📻 Channels</h2>
      <div id="channelsContainer" class="channels-container">
        <p class="loading">Loading channels...</p>
      </div>
    </div>

    <!-- Channel Recordings Modal -->
    <div id="channelModal" class="modal" style="display: none">
      <div class="modal-content">
        <div class="modal-header">
          <h2 id="modalChannelName">Channel Recordings</h2>
          <div class="modal-controls">
            <button onclick="refreshChannelRecordings()" class="refresh-btn" title="Refresh recordings list">
              ↻ Refresh
            </button>
            <span class="close" onclick="closeChannelModal()">&times;</span>
          </div>
        </div>

        <!-- Date Filter Controls -->
        <div class="date-filters">
          <div class="date-input-group">
            <label for="startDate">Start Date:</label>
            <input type="date" id="startDate" />
            <label for="startTime">Start Time:</label>
            <input type="time" id="startTime" />
          </div>
          <div class="date-input-group">
            <label for="endDate">End Date:</label>
            <input type="date" id="endDate" />
            <label for="endTime">End Time:</label>
            <input type="time" id="endTime" />
          </div>
          <button onclick="filterRecordings()" class="filter-btn">
            Apply Filter
          </button> (Times are approximate.)
        </div>

        <!-- Batch Selection Controls -->
        <div id="batchControls" class="batch-controls" style="display: none;">
          <h3>Batch Actions</h3>
          <div class="batch-actions">
            <span id="selectedCount" class="selected-count">0 selected</span>
            <button onclick="selectAllRecordings()" class="btn-select-all">Select All</button>
            <button onclick="clearSelection()" class="btn-select-all">Clear Selection</button>
            <button id="playBatchBtn" onclick="playSelectedRecordings()" class="btn-batch" disabled>
              Play Selected in Sequence
            </button>
            <button id="downloadBatchBtn" onclick="downloadSelectedRecordings()" class="btn-batch" disabled>
              Download Selected
            </button>
          </div>
        </div>

        <div id="modalRecordingsContainer" class="recording-list">
          <!-- Recordings will be loaded here -->
        </div>
      </div>
    </div>
  </div>
  </div>
  </div>
  </div>

  <script>
    console.log("Script tag loaded successfully");

    // Immediately try to call the API to test
    fetch("/api/channels")
      .then(response => {
        console.log("API Response:", response);
        return response.json();
      })
      .then(data => {
        console.log("API Data:", data);
      })
      .catch(error => {
        console.error("API Error:", error);
      });

    let refreshInterval;
    let currentChannelStats = {};
    let currentChannelId = null;
    let currentChannelName = null;

    // Los Angeles timezone offset
    const LA_TIMEZONE = "America/Los_Angeles";

    async function loadChannels() {
      console.log("Loading channels...");
      try {
        const [channelsResponse, statusResponse] = await Promise.all([
          fetch("/api/channels"),
          fetch("/api/status"),
        ]);

        const channels = await channelsResponse.json();
        const status = await statusResponse.json();
        console.log("Channels loaded:", Object.keys(channels).length);

        const container = document.getElementById("channelsContainer");
        // Clear any existing content
        container.innerHTML = "";

        if (Object.keys(channels).length === 0) {
          container.innerHTML = "<p>No channels configured</p>";
          return;
        }

        // Create table
        const table = document.createElement("table");
        table.className = "channels-table";

        // Create header
        table.innerHTML = `
            <thead>
              <tr>
                <th>Status</th>
                <th>Channel</th>
                <th>Group</th>
              </tr>
            </thead>
            <tbody id="channelsTableBody">
            </tbody>
          `;

        const tbody = table.querySelector("#channelsTableBody");

        // Create rows for each channel
        Object.entries(channels).forEach(([channelId, channel]) => {
          const isRecording = status[channelId]?.recording || false;
          const health = status[channelId]?.health || "unknown";
          const failures = status[channelId]?.consecutive_failures || 0;

          // Determine status display
          let statusClass, statusText;
          if (isRecording) {
            statusClass = "status-recording";
            statusText = "Recording";
          } else {
            switch (health) {
              case "healthy":
                statusClass = "status-healthy";
                statusText = "Healthy";
                break;
              case "warning":
                statusClass = "status-warning";
                statusText = `Warning (${failures} failures)`;
                break;
              case "degraded":
                statusClass = "status-degraded";
                statusText = `Degraded (${failures} failures)`;
                break;
              case "failed":
                statusClass = "status-failed";
                statusText = `Failed (${failures} failures)`;
                break;
              default:
                statusClass = "status-idle";
                statusText = "Idle";
            }
          }

          const row = document.createElement("tr");
          row.innerHTML = `
              <td>
                <span class="status-indicator ${statusClass}"></span>
                ${statusText}
              </td>
              <td>
                <div class="channel-name" data-channel-id="${channelId}" data-channel-name="${channel.name.replace(/"/g, '&quot;')}">
                  ${channel.name}
                </div>
              </td>
              <td>${channel.group || "Unknown"}</td>
            `;

          tbody.appendChild(row);
        });

        container.appendChild(table);

        // Add click event listeners to channel names
        const channelElements = document.querySelectorAll('.channel-name');
        console.log(`Adding click listeners to ${channelElements.length} channel elements`);
        console.log('First few channel elements:', channelElements);

        channelElements.forEach((element, index) => {
          console.log(`Adding listener to element ${index}:`, element);
          element.addEventListener('click', function (event) {
            console.log('Click event triggered!', event);
            const channelId = this.getAttribute('data-channel-id');
            const channelName = this.getAttribute('data-channel-name');
            console.log(`Channel clicked: ${channelId} - ${channelName}`);

            try {
              openChannelModal(channelId, channelName);
            } catch (error) {
              console.error('Error in openChannelModal:', error);
              alert('Error opening modal: ' + error.message);
            }
          });

          // Add visual feedback on hover
          element.style.cursor = 'pointer';
        });

        console.log("Table created and added to container");

        // Additional debugging - let's see what's actually in the DOM
        setTimeout(() => {
          const allChannelNames = document.querySelectorAll('.channel-name');
          console.log('Channel names found after timeout:', allChannelNames.length);
          if (allChannelNames.length > 0) {
            console.log('First channel element:', allChannelNames[0]);
            console.log('First channel data:', {
              id: allChannelNames[0].getAttribute('data-channel-id'),
              name: allChannelNames[0].getAttribute('data-channel-name'),
              text: allChannelNames[0].textContent
            });
          }
        }, 1000);
      } catch (error) {
        console.error("Error loading channels:", error);
        document.getElementById("channelsContainer").innerHTML =
          "<p>Error loading channels</p>";
      }
    }

    document.addEventListener("DOMContentLoaded", function () {
      console.log("DOM loaded - starting initialization");

      // Load channels and update status
      Promise.all([loadChannels(), updateStatus()])
        .then(() => {
          console.log("Initial load completed");
          // Set up auto-refresh every 5 seconds
          setInterval(() => {
            updateStatus();
          }, 5000);
        })
        .catch(error => {
          console.error("Error during initialization:", error);
        });
    });

    async function updateStatus() {
      try {
        const response = await fetch("/api/status");
        const status = await response.json();

        const recordingChannels = Object.values(status).filter(
          (s) => s.recording
        ).length;

        console.log(`Status update: ${recordingChannels} recording channels`);

        // Update system status
        const systemStatus = document.getElementById("systemStatus");
        const systemStatusText = document.getElementById("systemStatusText");

        if (recordingChannels > 0) {
          systemStatus.className = "status-indicator status-recording";
          systemStatusText.textContent = "Recording Active";
        } else {
          systemStatus.className = "status-indicator status-idle";
          systemStatusText.textContent = "System Idle";
        }

        // Update active channels count
        const activeChannelsElement = document.getElementById("activeChannels");
        console.log(`Updating activeChannels element with: ${recordingChannels}`);
        if (activeChannelsElement) {
          activeChannelsElement.textContent = recordingChannels;
        } else {
          console.error("activeChannels element not found!");
        }

        // Update total recordings count for today
        updateTodaysRecordingCount();
      } catch (error) {
        console.error("Error updating status:", error);
        const systemStatus = document.getElementById("systemStatus");
        const systemStatusText = document.getElementById("systemStatusText");
        systemStatus.className = "status-indicator status-idle";
        systemStatusText.textContent = "Connection Error";
        
        // Also update active channels and total recordings to show error state
        const activeChannelsElement = document.getElementById("activeChannels");
        if (activeChannelsElement) {
          activeChannelsElement.textContent = "N/A";
        }
        document.getElementById("totalRecordings").textContent = "Error";
      }
    }

    async function updateTodaysRecordingCount() {
      try {
        const response = await fetch("/api/stats");
        const stats = await response.json();
        
        if (stats.total && typeof stats.total.today === 'number') {
          document.getElementById("totalRecordings").textContent = stats.total.today;
        } else {
          document.getElementById("totalRecordings").textContent = "0";
        }
      } catch (error) {
        console.error("Error fetching stats:", error);
        document.getElementById("totalRecordings").textContent = "N/A";
      }
    }

    function formatDateForInput(date) {
      return date.toISOString().split("T")[0];
    }

    function formatDateTimeForLA(timestamp) {
      try {
        let date;

        // Handle different timestamp formats
        if (typeof timestamp === 'string') {
          // Check if it's in format YYYYMMDD_HHMMSS_mmm
          if (/^\d{8}_\d{6}_\d{3}/.test(timestamp)) {
            const year = parseInt(timestamp.substring(0, 4));
            const month = parseInt(timestamp.substring(4, 6)) - 1; // JS months are 0-based
            const day = parseInt(timestamp.substring(6, 8));
            const hour = parseInt(timestamp.substring(9, 11));
            const minute = parseInt(timestamp.substring(11, 13));
            const second = parseInt(timestamp.substring(13, 15));

            // Create date object directly - filename timestamps are already in PDT
            date = new Date(year, month, day, hour, minute, second);
          }
          // Check if it's in format YYYYMMDD_HHMMSS
          else if (/^\d{8}_\d{6}/.test(timestamp)) {
            const year = parseInt(timestamp.substring(0, 4));
            const month = parseInt(timestamp.substring(4, 6)) - 1; // JS months are 0-based
            const day = parseInt(timestamp.substring(6, 8));
            const hour = parseInt(timestamp.substring(9, 11));
            const minute = parseInt(timestamp.substring(11, 13));
            const second = parseInt(timestamp.substring(13, 15));

            // Create date object directly - filename timestamps are already in PDT
            date = new Date(year, month, day, hour, minute, second);
          }
          // Try to parse as ISO string or other standard formats
          else {
            date = new Date(timestamp);
          }
        } else {
          // Assume it's already a Date object or timestamp number
          date = new Date(timestamp);
        }

        // Check if date is valid
        if (isNaN(date.getTime())) {
          console.warn('Invalid date:', timestamp);
          return timestamp;
        }

        // Format for display - no timezone conversion needed since timestamps are already in PDT
        const options = {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        };

        return date.toLocaleString('en-US', options);
      } catch (e) {
        console.error('Error formatting date:', e, 'timestamp:', timestamp);
        return timestamp;
      }
    }

    function showMessage(message, type = "info") {
      console.log(`${type.toUpperCase()}: ${message}`);
      // Simple fallback - show as alert for errors, log others
      if (type === "error") {
        alert(`Error: ${message}`);
      }
    }

    async function refreshData() {
      try {
        await Promise.all([loadChannels(), loadStats(), updateStatus()]);
        document.getElementById(
          "lastUpdate"
        ).textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
      } catch (error) {
        console.error("Error refreshing data:", error);
        showMessage("Error refreshing data: " + error.message, "error");
      }
    }

    async function getLatestRecording(channelId) {
      try {
        const response = await fetch(`/api/recordings?channel=${channelId}&limit=1`);
        const recordings = await response.json();

        if (recordings.length === 0) {
          return 'None';
        }

        return formatDateTimeForLA(recordings[0].timestamp);
      } catch (error) {
        console.error("Error loading latest recording:", error);
        return 'Error';
      }
    }

    async function loadChannelStats() {
      try {
        const response = await fetch("/api/stats");
        const stats = await response.json();
        currentChannelStats = stats;
      } catch (error) {
        console.error("Error loading channel stats:", error);
      }
    }

    async function loadStats() {
      try {
        const response = await fetch("/api/stats");
        const stats = await response.json();

        const container = document.getElementById("statsContainer");
        container.innerHTML = "";

        const grid = document.createElement("div");
        grid.className = "stats-grid";

        if (stats.total) {
          grid.innerHTML = `
                        <div class="stat-card">
                            <div class="stat-number">${stats.total.recordings
            }</div>
                            <div class="stat-label">Total Recordings</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${stats.total.channels
            }</div>
                            <div class="stat-label">Channels</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${formatFileSize(
              stats.total.total_size
            )}</div>
                            <div class="stat-label">Total Size</div>
                        </div>
                    `;
        }

        container.appendChild(grid);
      } catch (error) {
        document.getElementById("statsContainer").innerHTML =
          '<p class="error">Error loading statistics</p>';
        throw error;
      }
    }

    async function openChannelModal(channelId, channelName) {
      console.log(`Opening channel modal for: ${channelId}, ${channelName}`);

      // Store current channel info for filtering
      currentChannelId = channelId;
      currentChannelName = channelName;

      document.getElementById("modalChannelName").textContent = `${channelName} Recordings`;
      document.getElementById("channelModal").style.display = "block";

      // Set default date range (last 7 days) for modal date inputs
      const today = new Date();
      const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
      document.getElementById("endDate").value = formatDateForInput(today);
      document.getElementById("startDate").value = formatDateForInput(weekAgo);

      // Set default times (start: 00:00, end: 23:59)
      document.getElementById("startTime").value = "00:00";
      document.getElementById("endTime").value = "23:59";

      const container = document.getElementById("modalRecordingsContainer");
      container.innerHTML = '<div class="loading">Loading recordings...</div>';

      try {
        const startDate = document.getElementById("startDate").value;
        const endDate = document.getElementById("endDate").value;
        const startTime = document.getElementById("startTime").value;
        const endTime = document.getElementById("endTime").value;

        let url = `/api/recordings/channel/${channelId}?limit=200`;
        if (startDate) {
          const startDateTime = startTime ? `${startDate}T${startTime}` : startDate;
          url += `&start_date=${startDateTime}`;
        }
        if (endDate) {
          const endDateTime = endTime ? `${endDate}T${endTime}` : endDate;
          url += `&end_date=${endDateTime}`;
        }

        console.log(`Fetching recordings from: ${url}`);
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        console.log(`Received data:`, data);
        console.log(`Recordings array length: ${data.recordings ? data.recordings.length : 'undefined'}`);

        container.innerHTML = "";

        // Handle both array response and object with recordings property
        const recordings = Array.isArray(data) ? data : data.recordings || [];
        console.log(`Processing ${recordings.length} recordings`);

        if (recordings.length > 0) {
          const list = document.createElement("div");
          list.className = "recording-list";

          recordings.forEach((recording, index) => {
            console.log(`Processing recording ${index}:`, recording);
            const item = document.createElement("div");
            item.className = "recording-item";

            // Simple fallback formatting
            let formattedTime = recording.timestamp || 'Unknown time';
            try {
              formattedTime = formatDateTimeForLA(recording.timestamp);
            } catch (e) {
              console.warn(`Date formatting failed for ${recording.timestamp}:`, e);
            }

            const duration = recording.duration_ms
              ? `${(recording.duration_ms / 1000).toFixed(1)}s`
              : recording.duration ? `${recording.duration}s` : "Unknown";

            item.innerHTML = `
                        <input type="checkbox" class="recording-checkbox" 
                               data-filename="${recording.filename}"
                               data-timestamp="${recording.timestamp}" 
                               onchange="updateBatchControls()">
                        <div class="recording-info">
                            <div class="recording-name">${recording.filename
              }</div>
                            <div class="recording-meta">
                                ${formattedTime} • ${duration} • ${formatFileSize(
                recording.size || 0
              )}
                            </div>
                        </div>
                        <div class="recording-actions">
                            <button class="btn-small btn-primary" onclick="playRecording('${recording.filename
              }', '${channelName}')">
                                Play
                            </button>
                            <button class="btn-small btn-info" onclick="downloadRecording('${recording.filename
              }')">
                                Download
                            </button>
                        </div>
                    `;

            list.appendChild(item);
          });

          container.appendChild(list);

          // Add pagination info if needed
          if (!Array.isArray(data) && data.has_more) {
            const info = document.createElement("div");
            info.className = "pagination";
            info.innerHTML = `<p>Showing ${recordings.length} of ${data.total} recordings</p>`;
            container.appendChild(info);
          }

          // Update batch controls
          updateBatchControls();
        } else {
          console.log('No recordings found. Data structure:', data);
          container.innerHTML = `
            <p>No recordings found for this channel in the selected date range</p>
            <p style="font-size: 0.8em; color: #888;">
              API URL: ${url}<br>
              Total records: ${data.total || 'N/A'}<br>
              Response type: ${Array.isArray(data) ? 'Array' : 'Object'}<br>
              Recordings array length: ${recordings.length}
            </p>
          `;

          // Hide batch controls when no recordings
          document.getElementById('batchControls').style.display = 'none';
        }
      } catch (error) {
        container.innerHTML = '<p class="error">Error loading channel recordings</p>';
        console.error("Error loading channel recordings:", error);

        // Hide batch controls on error
        document.getElementById('batchControls').style.display = 'none';
      }
    }

    function closeChannelModal() {
      document.getElementById("channelModal").style.display = "none";
    }

    function refreshChannelRecordings() {
      if (currentChannelId && currentChannelName) {
        console.log(`Refreshing recordings for channel: ${currentChannelId}`);
        
        // Show loading indicator
        const container = document.getElementById("modalRecordingsContainer");
        container.innerHTML = '<div class="loading">Refreshing recordings...</div>';
        
        // Use the same logic as openChannelModal but without changing the modal display
        const refreshModal = async () => {
          try {
            const startDate = document.getElementById("startDate").value;
            const endDate = document.getElementById("endDate").value;
            const startTime = document.getElementById("startTime").value;
            const endTime = document.getElementById("endTime").value;

            let url = `/api/recordings/channel/${currentChannelId}?limit=200`;
            if (startDate) {
              const startDateTime = startTime ? `${startDate}T${startTime}` : startDate;
              url += `&start_date=${startDateTime}`;
            }
            if (endDate) {
              const endDateTime = endTime ? `${endDate}T${endTime}` : endDate;
              url += `&end_date=${endDateTime}`;
            }

            console.log(`Refreshing recordings from: ${url}`);
            const response = await fetch(url);

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            console.log(`Refreshed data:`, data);

            container.innerHTML = "";

            // Handle both array response and object with recordings property
            const recordings = Array.isArray(data) ? data : data.recordings || [];
            console.log(`Processing ${recordings.length} recordings`);

            if (recordings.length > 0) {
              const list = document.createElement("div");
              list.className = "recording-list";

              recordings.forEach((recording, index) => {
                console.log(`Processing recording ${index}:`, recording);
                const item = document.createElement("div");
                item.className = "recording-item";

                // Simple fallback formatting
                let formattedTime = recording.timestamp || 'Unknown time';
                try {
                  formattedTime = formatDateTimeForLA(recording.timestamp);
                } catch (e) {
                  console.warn(`Date formatting failed for ${recording.timestamp}:`, e);
                }

                const duration = recording.duration_ms
                  ? `${(recording.duration_ms / 1000).toFixed(1)}s`
                  : recording.duration ? `${recording.duration}s` : "Unknown";

                item.innerHTML = `
                        <input type="checkbox" class="recording-checkbox" 
                               data-filename="${recording.filename}"
                               data-timestamp="${recording.timestamp}" 
                               onchange="updateBatchControls()">
                        <div class="recording-info">
                            <div class="recording-name">${recording.filename}</div>
                            <div class="recording-meta">
                                ${formattedTime} • ${duration} • ${formatFileSize(recording.size || 0)}
                            </div>
                        </div>
                        <div class="recording-actions">
                            <button class="btn-small btn-primary" onclick="playRecording('${recording.filename}', '${currentChannelName}')">
                                Play
                            </button>
                            <button class="btn-small btn-info" onclick="downloadRecording('${recording.filename}')">
                                Download
                            </button>
                        </div>
                    `;

                list.appendChild(item);
              });

              container.appendChild(list);

              // Add pagination info if needed
              if (!Array.isArray(data) && data.has_more) {
                const info = document.createElement("div");
                info.className = "pagination";
                info.innerHTML = `<p>Showing ${recordings.length} of ${data.total} recordings</p>`;
                container.appendChild(info);
              }

              // Update batch controls
              updateBatchControls();
            } else {
              container.innerHTML = '<div class="no-recordings">No recordings found for the selected date range.</div>';
            }
          } catch (error) {
            console.error('Error refreshing recordings:', error);
            container.innerHTML = `<div class="error">Error refreshing recordings: ${error.message}</div>`;
          }
        };

        refreshModal();
      } else {
        console.warn('No channel selected for refresh');
      }
    }

    function filterRecordings() {
      if (!currentChannelId || !currentChannelName) {
        console.error("No channel selected for filtering");
        return;
      }

      console.log(`Filtering recordings for channel: ${currentChannelId}`);
      
      // Show loading indicator
      const container = document.getElementById("modalRecordingsContainer");
      container.innerHTML = '<div class="loading">Filtering recordings...</div>';
      
      // Get the current date/time values from the form
      const startDate = document.getElementById("startDate").value;
      const endDate = document.getElementById("endDate").value;
      const startTime = document.getElementById("startTime").value;
      const endTime = document.getElementById("endTime").value;

      console.log('Filter inputs:', { startDate, endDate, startTime, endTime });

      // Build URL with date/time filters
      let url = `/api/recordings/channel/${currentChannelId}?limit=200`;
      
      if (startDate) {
        const startDateTime = startTime ? `${startDate}T${startTime}` : startDate;
        url += `&start_date=${startDateTime}`;
      }
      
      if (endDate) {
        const endDateTime = endTime ? `${endDate}T${endTime}` : endDate;
        url += `&end_date=${endDateTime}`;
      }

      console.log(`Filtering recordings with URL: ${url}`);

      // Fetch filtered recordings
      fetch(url)
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          return response.json();
        })
        .then(data => {
          console.log(`Filter returned ${Array.isArray(data) ? data.length : data.recordings?.length || 0} recordings`);
          
          // Handle both array response and object with recordings property
          const recordings = Array.isArray(data) ? data : data.recordings || [];
          
          container.innerHTML = "";
          
          if (recordings.length > 0) {
            console.log(`Processing ${recordings.length} recordings`);
            const list = document.createElement("div");
            list.className = "recording-list";

            recordings.forEach((recording, index) => {
              console.log(`Processing recording ${index}:`, recording);
              const item = document.createElement("div");
              item.className = "recording-item";

              // Simple fallback formatting
              let formattedTime = recording.timestamp || 'Unknown time';
              try {
                formattedTime = formatDateTimeForLA(recording.timestamp);
              } catch (e) {
                console.warn(`Date formatting failed for ${recording.timestamp}:`, e);
              }

              const duration = recording.duration_ms
                ? `${(recording.duration_ms / 1000).toFixed(1)}s`
                : recording.duration ? `${recording.duration}s` : "Unknown";

              item.innerHTML = `
                      <input type="checkbox" class="recording-checkbox" 
                             data-filename="${recording.filename}"
                             data-timestamp="${recording.timestamp}" 
                             onchange="updateBatchControls()">
                      <div class="recording-info">
                          <div class="recording-name">${recording.filename}</div>
                          <div class="recording-meta">
                              ${formattedTime} • ${duration} • ${formatFileSize(recording.size || 0)}
                          </div>
                      </div>
                      <div class="recording-actions">
                          <button class="btn-small btn-primary" onclick="playRecording('${recording.filename}', '${currentChannelName}')">
                              Play
                          </button>
                          <button class="btn-small btn-info" onclick="downloadRecording('${recording.filename}')">
                              Download
                          </button>
                      </div>
                  `;

              list.appendChild(item);
            });

            container.appendChild(list);

            // Add pagination info if needed
            if (!Array.isArray(data) && data.has_more) {
              const info = document.createElement("div");
              info.className = "pagination";
              info.innerHTML = `<p>Showing ${recordings.length} of ${data.total} recordings</p>`;
              container.appendChild(info);
            }

            // Update batch controls
            updateBatchControls();
          } else {
            container.innerHTML = '<div class="no-recordings">No recordings found for the selected date range.</div>';
          }
        })
        .catch(error => {
          console.error('Error filtering recordings:', error);
          container.innerHTML = `<div class="error">Error filtering recordings: ${error.message}</div>`;
        });
    }

    // Close modal when clicking outside
    window.onclick = function (event) {
      const modal = document.getElementById("channelModal");
      if (event.target == modal) {
        modal.style.display = "none";
      }
    };

    function getAudioSources(filename) {
      // Generate appropriate audio source tags based on file extension
      const fileExtension = filename.toLowerCase().split('.').pop();
      const baseSrc = `/api/recording/${filename}`;
      
      if (fileExtension === 'flac') {
        return `<source src="${baseSrc}" type="audio/flac">
                <source src="${baseSrc}" type="audio/x-flac">`;
      } else if (fileExtension === 'mp3') {
        return `<source src="${baseSrc}" type="audio/mpeg">
                <source src="${baseSrc}" type="audio/mp3">`;
      } else {
        // Default fallback for unknown extensions
        return `<source src="${baseSrc}" type="audio/mpeg">
                <source src="${baseSrc}" type="audio/mp3">`;
      }
    }

    function playRecording(filename, channelName) {
      // Create a modal or popup with audio player
      const audioModal = document.createElement("div");
      audioModal.className = "modal";
      audioModal.style.display = "block";

      audioModal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h3>Playing: ${channelName}</h3>
                        <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
                    </div>
                    <div style="padding: 20px;">
                        <p style="margin-bottom: 15px; color: #bdc3c7;">${filename}</p>
                        <div id="audio-status" style="margin-bottom: 10px; color: #3498db; font-size: 14px;">Loading audio...</div>
                        <audio controls preload="metadata" class="audio-player" id="audio-player-${Date.now()}">
                            ${getAudioSources(filename)}
                            Your browser does not support the audio element.
                        </audio>
                    </div>
                </div>
            `;

      document.body.appendChild(audioModal);

      // Get the audio element and add event listeners
      const audioElement = audioModal.querySelector('audio');
      const statusElement = audioModal.querySelector('#audio-status');

      audioElement.addEventListener('loadedmetadata', function () {
        const duration = audioElement.duration;
        if (duration && !isNaN(duration)) {
          statusElement.textContent = `Duration: ${duration.toFixed(1)}s`;
          statusElement.style.color = '#27ae60';
          // Auto-play after metadata is loaded
          audioElement.play().catch(e => {
            statusElement.textContent = 'Click play to start (autoplay blocked)';
            statusElement.style.color = '#f39c12';
          });
        } else {
          statusElement.textContent = 'Duration unknown - file may be corrupted';
          statusElement.style.color = '#e74c3c';
        }
      });

      audioElement.addEventListener('error', function (e) {
        statusElement.textContent = 'Error loading audio file';
        statusElement.style.color = '#e74c3c';
        console.error('Audio error:', e);
      });

      audioElement.addEventListener('canplay', function () {
        if (statusElement.textContent === 'Loading audio...') {
          statusElement.textContent = 'Ready to play';
          statusElement.style.color = '#27ae60';
        }
      });

      // Close when clicking outside
      audioModal.onclick = function (event) {
        if (event.target === audioModal) {
          audioModal.remove();
        }
      };
    }

    async function startRecording(channelIds = null) {
      try {
        const response = await fetch("/api/start", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ channels: channelIds }),
        });

        const result = await response.json();

        if (result.status === "success") {
          showMessage(result.message, "success");
          refreshData();
        } else {
          showMessage(result.message, "error");
        }
      } catch (error) {
        showMessage("Error starting recording: " + error.message, "error");
      }
    }

    async function stopRecording(channelIds = null) {
      try {
        const response = await fetch("/api/stop", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ channels: channelIds }),
        });

        const result = await response.json();

        if (result.status === "success") {
          showMessage(result.message, "success");
          refreshData();
        } else {
          showMessage(result.message, "error");
        }
      } catch (error) {
        showMessage("Error stopping recording: " + error.message, "error");
      }
    }

    function startAllRecording() {
      startRecording();
    }

    function stopAllRecording() {
      stopRecording();
    }

    function downloadRecording(filename) {
      window.open(`/api/recording/${filename}`, "_blank");
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }

    // Batch recording selection and playback functions
    let currentAudioPlayer = null;
    let batchPlaybackQueue = [];
    let currentPlaybackIndex = 0;

    function updateBatchControls() {
      const checkboxes = document.querySelectorAll('.recording-checkbox:checked');
      const count = checkboxes.length;

      const selectedCountElement = document.getElementById('selectedCount');
      const playBatchBtn = document.getElementById('playBatchBtn');
      const downloadBatchBtn = document.getElementById('downloadBatchBtn');
      const batchControls = document.getElementById('batchControls');

      selectedCountElement.textContent = `${count} selected`;
      playBatchBtn.disabled = count === 0;
      downloadBatchBtn.disabled = count === 0;

      // Show/hide batch controls based on whether any recordings exist
      const allCheckboxes = document.querySelectorAll('.recording-checkbox');
      batchControls.style.display = allCheckboxes.length > 0 ? 'block' : 'none';
    }

    function selectAllRecordings() {
      const checkboxes = document.querySelectorAll('.recording-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = true;
      });
      updateBatchControls();
    }

    function clearSelection() {
      const checkboxes = document.querySelectorAll('.recording-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
      });
      updateBatchControls();
    }

    function playSelectedRecordings() {
      const selectedCheckboxes = document.querySelectorAll('.recording-checkbox:checked');
      if (selectedCheckboxes.length === 0) {
        showMessage('Please select recordings to play', 'error');
        return;
      }

      // Build queue of selected recordings with timestamp information
      const selectedRecordings = Array.from(selectedCheckboxes).map(checkbox => {
        const filename = checkbox.getAttribute('data-filename');
        const timestamp = checkbox.getAttribute('data-timestamp');

        console.log('Raw timestamp for', filename, ':', timestamp);

        // Parse timestamp from YYYYMMDD_HHMMSS format to proper Date
        let parsedDate;
        try {
          if (timestamp && timestamp.match(/^\d{8}_\d{6}/)) {
            // Format: YYYYMMDD_HHMMSS
            const year = timestamp.substring(0, 4);
            const month = timestamp.substring(4, 6);
            const day = timestamp.substring(6, 8);
            const hour = timestamp.substring(9, 11);
            const minute = timestamp.substring(11, 13);
            const second = timestamp.substring(13, 15);
            parsedDate = new Date(year, month - 1, day, hour, minute, second);
          } else {
            // Fallback to direct parsing
            parsedDate = new Date(timestamp);
          }
        } catch (e) {
          console.warn('Failed to parse timestamp:', timestamp, e);
          parsedDate = new Date(0); // Fallback to epoch
        }

        return {
          filename: filename,
          timestamp: parsedDate,
          rawTimestamp: timestamp
        };
      });

      // Sort recordings by timestamp (oldest to newest)
      selectedRecordings.sort((a, b) => {
        const result = a.timestamp - b.timestamp;
        console.log('Comparing:', a.filename, '(', a.timestamp, ') vs', b.filename, '(', b.timestamp, ') result:', result);
        return result;
      });

      // Extract sorted filenames for playback queue
      batchPlaybackQueue = selectedRecordings.map(recording => recording.filename);
      currentPlaybackIndex = 0;

      console.log('Selected recordings with timestamps:', selectedRecordings);
      console.log('Playing recordings in chronological order:', batchPlaybackQueue);

      // Start playing the first recording
      playBatchRecording();
    }

    function playBatchRecording() {
      if (currentPlaybackIndex >= batchPlaybackQueue.length) {
        showMessage('Batch playback completed', 'success');
        return;
      }

      const filename = batchPlaybackQueue[currentPlaybackIndex];
      const channelName = currentChannelName || 'Unknown Channel';

      // Remove any existing audio modal
      const existingModal = document.querySelector('.batch-audio-modal');
      if (existingModal) {
        existingModal.remove();
      }

      // Create a modal for batch playback
      const audioModal = document.createElement("div");
      audioModal.className = "modal batch-audio-modal";
      audioModal.style.display = "block";

      audioModal.innerHTML = `
        <div class="modal-content" style="max-width: 600px;">
          <div class="modal-header">
            <h3>Batch Playback: ${channelName}</h3>
            <span class="close" onclick="stopBatchPlayback()">&times;</span>
          </div>
          <div style="padding: 20px;">
            <p><strong>Playing ${currentPlaybackIndex + 1} of ${batchPlaybackQueue.length}:</strong></p>
            <p style="word-break: break-all; font-size: 0.9em; color: #666;">${filename}</p>
            <audio controls autoplay style="width: 100%; margin: 15px 0;">
              ${getAudioSources(filename)}
              Your browser does not support the audio element.
            </audio>
            <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: space-between;">
              <div>
                <button onclick="previousBatchRecording()" ${currentPlaybackIndex === 0 ? 'disabled' : ''} 
                        class="btn-small btn-info">Previous</button>
                <button onclick="nextBatchRecording()" 
                        class="btn-small btn-primary">Next</button>
              </div>
              <button onclick="stopBatchPlayback()" class="btn-small btn-secondary">Stop Batch</button>
            </div>
          </div>
        </div>
      `;

      document.body.appendChild(audioModal);

      // Get the audio element and set up event listeners
      currentAudioPlayer = audioModal.querySelector('audio');

      currentAudioPlayer.addEventListener('ended', () => {
        currentPlaybackIndex++;
        setTimeout(() => {
          playBatchRecording();
        }, 500); // Small delay between recordings
      });

      currentAudioPlayer.addEventListener('error', (e) => {
        console.error('Audio playback error:', e);
        showMessage(`Error playing ${filename}`, 'error');
        currentPlaybackIndex++;
        setTimeout(() => {
          playBatchRecording();
        }, 1000);
      });
    }

    function nextBatchRecording() {
      if (currentPlaybackIndex < batchPlaybackQueue.length - 1) {
        currentPlaybackIndex++;
        playBatchRecording();
      }
    }

    function previousBatchRecording() {
      if (currentPlaybackIndex > 0) {
        currentPlaybackIndex--;
        playBatchRecording();
      }
    }

    function stopBatchPlayback() {
      const modal = document.querySelector('.batch-audio-modal');
      if (modal) {
        modal.remove();
      }
      if (currentAudioPlayer) {
        currentAudioPlayer.pause();
        currentAudioPlayer = null;
      }
      batchPlaybackQueue = [];
      currentPlaybackIndex = 0;
    }

    function downloadSelectedRecordings() {
      const selectedCheckboxes = document.querySelectorAll('.recording-checkbox:checked');
      if (selectedCheckboxes.length === 0) {
        showMessage('Please select recordings to download', 'error');
        return;
      }

      if (selectedCheckboxes.length === 1) {
        // For single file, use regular download
        const filename = selectedCheckboxes[0].getAttribute('data-filename');
        downloadRecording(filename);
        return;
      }

      // Collect selected recordings with timestamps for sorting
      const selectedRecordings = Array.from(selectedCheckboxes).map(checkbox => {
        const filename = checkbox.getAttribute('data-filename');
        const timestamp = checkbox.getAttribute('data-timestamp');
        
        console.log(`Processing selected file: ${filename} with timestamp: ${timestamp}`);

        // Parse timestamp from YYYYMMDD_HHMMSS format to proper Date
        let parsedDate;
        try {
          if (timestamp && timestamp.match(/^\d{8}_\d{6}/)) {
            // Format: YYYYMMDD_HHMMSS
            const year = timestamp.substring(0, 4);
            const month = timestamp.substring(4, 6);
            const day = timestamp.substring(6, 8);
            const hour = timestamp.substring(9, 11);
            const minute = timestamp.substring(11, 13);
            const second = timestamp.substring(13, 15);
            parsedDate = new Date(year, month - 1, day, hour, minute, second);
          } else {
            // Fallback to direct parsing
            parsedDate = new Date(timestamp);
          }
        } catch (e) {
          console.warn('Failed to parse timestamp:', timestamp, e);
          parsedDate = new Date(0); // Fallback to epoch
        }

        return {
          filename: filename,
          timestamp: parsedDate,
          rawTimestamp: timestamp
        };
      });

      // Sort recordings by timestamp (oldest to newest)
      selectedRecordings.sort((a, b) => a.timestamp - b.timestamp);

      // Extract sorted filenames
      const sortedFilenames = selectedRecordings.map(recording => recording.filename);
      
      console.log(`Total selected recordings: ${selectedRecordings.length}`);
      console.log('Selected files with details:', selectedRecordings.map(r => ({
        filename: r.filename,
        timestamp: r.timestamp.toISOString(),
        rawTimestamp: r.rawTimestamp
      })));
      console.log('Final sorted filenames for download:', sortedFilenames);

      // Show confirmation dialog with file list
      const fileListForUser = sortedFilenames.map((f, i) => `${i + 1}. ${f}`).join('\n');
      const confirmed = confirm(
        `You're about to download and concatenate ${selectedRecordings.length} recordings.\n\n` +
        `Files will be combined in chronological order:\n\n${fileListForUser}\n\n` +
        `Continue with download?`
      );

      if (!confirmed) {
        console.log('User cancelled batch download');
        return;
      }

      // Show loading message
      showMessage(`Preparing concatenated download of ${selectedRecordings.length} recordings...`, 'info');

      // Disable the download button during processing
      const downloadBtn = document.getElementById('downloadBatchBtn');
      const originalText = downloadBtn.textContent;
      downloadBtn.disabled = true;
      downloadBtn.textContent = 'Processing...';

      // Make API call to concatenate and download
      const requestData = {
        files: sortedFilenames,
        channel_name: currentChannelName || 'mixed'
      };

      fetch('/api/concatenate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData)
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        console.log('Concatenation response:', data);
        
        if (data.success) {
          console.log(`Successfully concatenated ${data.files_concatenated} files:`);
          console.log('Files included:', data.file_list);
          
          // Create download link
          const a = document.createElement('a');
          a.href = data.download_url;
          a.download = data.filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          
          showMessage(
            `Successfully concatenated ${data.files_concatenated} recordings into ${data.filename}. ` +
            `Files included: ${data.file_list.join(', ')}`, 
            'success'
          );
        } else {
          throw new Error(data.error || 'Unknown error');
        }
      })
      .catch(error => {
        console.error('Error downloading concatenated recordings:', error);
        showMessage('Error creating concatenated download: ' + error.message, 'error');
      })
      .finally(() => {
        // Re-enable the download button
        downloadBtn.disabled = false;
        downloadBtn.textContent = originalText;
        updateBatchControls(); // Update button state based on current selection
      });
    }
  </script>

</body>

</html>